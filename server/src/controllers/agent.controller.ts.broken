import { Request, Response } from 'express';
import HandoffTicket from '../shared/models/HandoffTicket.model';
import User from '../shared/models/User.model';
import { Types } from 'mongoose';
import { getIO } from '../socket/socketServer';

/**
 * Agent Controller
 * Handles HTTP requests for agent operations
 */

/**
 * Get all pending tickets (for agents)
 */
export const getPendingTickets = async (req: Request, res: Response): Promise<void> => {
  try {
    const userId = (req as any).user?.userId;

    if (!userId) {
      res.status(401).json({
        success: false,
        message: 'Unauthorized',
      });
      return;
    }

    // Verify user is an agent
    const user = await User.findById(userId);
    if (!user || user.role !== 'agent') {
      res.status(403).json({
        success: false,
        message: 'Access denied. Agent role required.',
      });
      return;
    }

    // Get all waiting tickets, sorted by priority and creation time
    const tickets = await HandoffTicket.find({
      status: 'waiting',
    })
      .sort({ priority: -1, createdAt: 1 })
      .populate('userId', 'name email')
      .lean();

    res.status(200).json({
      success: true,
      data: tickets,
    });
  } catch (error) {
    console.error('Error fetching pending tickets:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to fetch pending tickets',
    });
  }
};

/**
 * Get agent's assigned tickets
 */
export const getAssignedTickets = async (req: Request, res: Response): Promise<void> => {
  try {
    const agentId = (req as any).user?.userId;

    if (!agentId) {
      res.status(401).json({
        success: false,
        message: 'Unauthorized',
      });
      return;
    }

    // Verify user is an agent
    const user = await User.findById(agentId);
    if (!user || user.role !== 'agent') {
      res.status(403).json({
        success: false,
        message: 'Access denied. Agent role required.',
      });
      return;
    }

    const tickets = await HandoffTicket.find({
      assignedAgentId: new Types.ObjectId(agentId),
      status: 'assigned',
    })
      .sort({ assignedAt: -1 })
      .populate('userId', 'name email')
      .lean();

    res.status(200).json({
      success: true,
      data: tickets,
    });
  } catch (error) {
    console.error('Error fetching assigned tickets:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to fetch assigned tickets',
    });
  }
};

/**
 * Accept a ticket
 */
export const acceptTicket = async (req: Request, res: Response): Promise<void> => {
  try {
    const agentId = (req as any).user?.userId;
    const { id } = req.params;

    if (!agentId) {
      res.status(401).json({
        success: false,
        message: 'Unauthorized',
      });
      return;
    }

    // Verify user is an agent
    const agent = await User.findById(agentId);
    if (!agent || agent.role !== 'agent') {
      res.status(403).json({
        success: false,
        message: 'Access denied. Agent role required.',
      });
      return;
    }

    // Check if agent is available
    if (agent.agentStatus !== 'available') {
      res.status(400).json({
        success: false,
        message: 'Agent must be available to accept tickets',
      });
      return;
    }

    // Find and update ticket
    const agentName = `${agent.firstName} ${agent.lastName}`;
    
    const ticket = await HandoffTicket.findOneAndUpdate(
      {
        _id: new Types.ObjectId(id),
        status: 'waiting',
      },
      {
        $set: {
          status: 'assigned',
          assignedAgentId: new Types.ObjectId(agentId),
          assignedAgentName: agentName,
          assignedAt: new Date(),
        },
      },
      { new: true }
    ).populate('userId', 'firstName lastName email');

    if (!ticket) {
      res.status(404).json({
        success: false,
        message: 'Ticket not found or already assigned',
      });
      return;
    }

    // Update agent status to busy
    await User.findByIdAndUpdate(agentId, {
      $set: { agentStatus: 'busy' },
    });

    // Notify user via Socket.io
    const io = getIO();
    io.to(`user:${ticket.userId}`).emit('handoff:agent-assigned', {
      ticketId: ticket._id,
      agentName: agentName,
      message: `${agentName} has joined the conversation`,
    });

    res.status(200).json({
      success: true,
      message: 'Ticket accepted successfully',
      data: ticket,
    });
  } catch (error) {
    console.error('Error accepting ticket:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to accept ticket',
    });
  }
};

/**
 * Resolve a ticket
 */
export const resolveTicket = async (req: Request, res: Response): Promise<void> => {
  try {
    const agentId = (req as any).user?.userId;
    const { id } = req.params;
    const { resolutionNotes } = req.body;

    if (!agentId) {
      res.status(401).json({
        success: false,
        message: 'Unauthorized',
      });
      return;
    }

    // Find and update ticket
    const ticket = await HandoffTicket.findOneAndUpdate(
      {
        _id: new Types.ObjectId(id),
        assignedAgentId: new Types.ObjectId(agentId),
        status: 'assigned',
      },
      {
        $set: {
          status: 'resolved',
          resolvedAt: new Date(),
          resolutionNotes: resolutionNotes || 'Issue resolved',
        },
      },
      { new: true }
    );

    if (!ticket) {
      res.status(404).json({
        success: false,
        message: 'Ticket not found or not assigned to you',
      });
      return;
    }

    // Update agent status to available
    await User.findByIdAndUpdate(agentId, {
      $set: { agentStatus: 'available' },
    });

    // Notify user via Socket.io
    const io = getIO();
    io.to(`user:${ticket.userId}`).emit('handoff:resolved', {
      ticketId: ticket._id,
      message: 'Your issue has been resolved. You can continue chatting with the AI.',
    });

    res.status(200).json({
      success: true,
      message: 'Ticket resolved successfully',
      data: ticket,
    });
  } catch (error) {
    console.error('Error resolving ticket:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to resolve ticket',
    });
  }
};

/**
 * Update agent status
 */
export const updateAgentStatus = async (req: Request, res: Response): Promise<void> => {
  try {
    const agentId = (req as any).user?.userId;
    const { status } = req.body;

    if (!agentId) {
      res.status(401).json({
        success: false,
        message: 'Unauthorized',
      });
      return;
    }

    // Validate status
    if (!['available', 'busy', 'offline'].includes(status)) {
      res.status(400).json({
        success: false,
        message: 'Invalid status. Must be: available, busy, or offline',
      });
      return;
    }

    // Verify user is an agent
    const agent = await User.findById(agentId);
    if (!agent || agent.role !== 'agent') {
      res.status(403).json({
        success: false,
        message: 'Access denied. Agent role required.',
      });
      return;
    }

    // Update agent status
    agent.agentStatus = status;
    await agent.save();

    res.status(200).json({
      success: true,
      message: 'Agent status updated successfully',
      data: {
        status: agent.agentStatus,
      },
    });
  } catch (error) {
    console.error('Error updating agent status:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to update agent status',
    });
  }
};

/**
 * Get agent statistics
 */
export const getAgentStats = async (req: Request, res: Response): Promise<void> => {
  try {
    const agentId = (req as any).user?.userId;

    if (!agentId) {
      res.status(401).json({
        success: false,
        message: 'Unauthorized',
      });
      return;
    }

    // Verify user is an agent
    const agent = await User.findById(agentId);
    if (!agent || agent.role !== 'agent') {
      res.status(403).json({
        success: false,
        message: 'Access denied. Agent role required.',
      });
      return;
    }

    // Get statistics
    const totalResolved = await HandoffTicket.countDocuments({
      assignedAgentId: new Types.ObjectId(agentId),
      status: 'resolved',
    });

    const currentlyAssigned = await HandoffTicket.countDocuments({
      assignedAgentId: new Types.ObjectId(agentId),
      status: 'assigned',
    });

    const pendingInQueue = await HandoffTicket.countDocuments({
      status: 'waiting',
    });

    res.status(200).json({
      success: true,
      data: {
        totalResolved,
        currentlyAssigned,
        pendingInQueue,
        status: agent.agentStatus,
      },
    });
  } catch (error) {
    console.error('Error fetching agent stats:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to fetch agent statistics',
    });
  }
};
